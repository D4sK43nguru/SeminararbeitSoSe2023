\newpage
\section[Anwendung von Kryptografie in Webanwendungen]{Anwendung von \gls{kryptografie} in Webanwendungen}\label{sec:anwendung_von_kryptografie_in_webanwendungen}
In der heutigen vernetzten Welt sind Webanwendungen allgegenwärtig und spielen eine wichtige Rolle, um Dienste bereitzustellen und sensible Informationen auszutauschen. In diesem Kapitel geht es um den Einsatz von \gls{kryptografie} in Webanwendungen. Damit sollen die Sicherheitsanforderungen an \gls{vertraulichkeit}, \gls{integritaet} und \gls{verfügbarkeit} erfüllt werden.

Zunächst werden die grundlegenden Sicherheitsanforderungen an Web-Anwendungen erläutert. Anschließend wird gezeigt, wie \gls{kryptografie} eingesetzt werden kann, um sensible Daten vor unberechtigtem Zugriff zu schützen.

Die Verschlüsselung der Datenübertragung ist ein zentraler Aspekt der Sicherheit von Web-Anwendungen. Um Daten während der Übertragung zu schützen, konzentriert sich der nächste Abschnitt auf das \ac{HTTPS}-Protokoll und die \ac{SSL}/ \acf{TLS}-Verschlüsselung.

Die Sicherheit von Passwörtern wird ebenfalls behandelt. Methoden wie Salted Hashing und Key Derivation Functions werden vorgestellt, um Passwörter sicher zu speichern.

In den Abschnitten über \gls{authentifizierung} und \gls{autorisierung} werden verschiedene Verfahren und Protokolle, wie z. B. Token-basierte Verfahren und OAuth, vorgestellt, um die Identitätsprüfung und Zugriffskontrolle in Web-Anwendungen zu gewährleisten.

Ziel dieses Kapitels ist ein umfassender Einblick in den Einsatz von \gls{kryptografie} in Webanwendungen zur Gewährleistung von \gls{vertraulichkeit}, \gls{integritaet} und \gls{verfügbarkeit}.

\subsection[Sicherheitsanforderungen an Webanwendungen]{Sicherheitsanforderungen an Webanwendungen — \gls{vertraulichkeit}, \gls{integritaet}, \gls{verfügbarkeit}}

Das \ac{BSI} listet für die Webanwendung drei primäre Schutzziele
\begin{samepage}
\begin{itemize}
    \item \gls{vertraulichkeit},
    \item \gls{integritaet} sowie
    \item \gls{verfügbarkeit}
\end{itemize}
\end{samepage}
von denen zudem abgeleitet u.a. die beiden sekundäre Schutzziele
\begin{samepage}
    \begin{itemize}
        \item \gls{authentizität} und 
        \item \gls{nonAbstreitbarkeit}
    \end{itemize}
\end{samepage}
aufgeführt sind\autocite[\pagef~8]{bsi_leitfaden_2022}.

Das Zusammenarbeiten der Schutzziele, insbesondere der drei primären Schutzziele, zur garantie einer sicheren Webanwendung wird im Folgenden untersucht.

\subsection[Verschlüsselung von Datenübertragungen]{Verschlüsselung von Datenübertragungen — \ac{SSL}/\ac{TLS}-Verschlüsselung, \ac{HTTPS}-Protokoll}

Es gibt verschiedene Methoden, eine Datenübertragung im Internet zu verschlüsseln. Die wahrscheinlich bekannteste ist das \ac{HTTPS}-Protokoll, welches im \autoref{subsubsec:HTTPS-Protocol} untersucht wird. \autoref{subsubsec:digitale-signaturen-und-zertifikate}

\subsubsection[Digitale Zertifikate]{Digitale Zertifikate — \ac{SSL}/\ac{TLS}-Verschlüsselung}\label{subsubsec:digitale-signaturen-und-zertifikate} befasst sich mit der Generierung von digitalen Zertifikaten zur Verifizierung der Echtheit der Daten.

Eine digitale Signatur ist ein \gls{publicKeyEncoding}, bei dem einer Nachricht ein einzigartiger Schlüssel angehangen wird, der meist daraus generiert wird, dass der \gls{hashwert} (\autoref{subsubsec:hash-funktion}) einer Nachricht mit dem \gls{privateKey} des Empfängers verschlüsselt wird\autocite[\pagef~297]{6391693}. Als \ac{NIST}-Standard wird dabei ein \ac{SHA}-\gls{algorithmus} verwendet.
Der \gls{klartext}, die Signatur und der \gls{publicKey} des Senders werden dann zusammengepackt und mit dem \gls{publicKey} des Empfängers zusammen verschlüsselt. Diese signierte und verschlüsselte Nachricht wird dann übermittelt.\autocite[\pagef~297]{6391693}

Um die Nachricht zu entschlüsseln, wird wie bei einer normalen \gls{publicKeyEncoding} der \gls{privateKey} des Empfängers entsprechend des genutzten Verschlüsselungsvefahren auf die Nachricht angewandt. Anschließend wird der \gls{klartext} der Nachricht gehashed und die Signatur mit dem \gls{publicKey} des Senders entschlüsselt. Diese beiden Werte werden verglichen, ob sie identisch sind. Sind sie es, so ist die Nachricht verifiziert, andernfalls nicht.\autocite[\pagef~297]{6391693}

Ein wichtiges Werkzeug der sicheren Webentwicklung sind \ac{SSL} und \ac{TLS} Zertifikate. \ac{TLS} ist dabei der Nachfolger für \ac{SSL}, beide nutzen aber das gleiche selbe \gls{X509} Zertifikat\footnote{Aus Gründen der Überblicklichkeit und der Ähnlichkeit der beiden Zertifikate, werden im Folgenden \ac{SSL}/\ac{TLS} vereinfachend als \ac{SSL} bezeichnet.}. Mit \ac{SSL} kann ein \gls{client} überprüfen, ob das Zertifikat des angefragten \glspl{server} von einer vertrauten Autorität ausgestellt wurde oder nicht, indem die digitalen \gls{X509} Zertifikate verifiziert werden. Andernfalls wird die Verbindung abgelehnt.\autocite[\pagef~1]{zhang_analysis_2014}

Im \gls{osi} liegt \ac{SSL} auf Ebene 4, der Transportebene\autocite{HowTLSSS99:online} und ist eine \enquote{externe Überprüfung durch einen vertrauenswürdigen Dritten, der garantiert, dass ein Webserver der ist, der er vorgibt zu sein}\autocite[Grund Nr. 3]{CloudfareWarumHTTPS:online}.

Das \ac{TLS}-Protokoll lässt sich, wie in \autoref{tab:tls-protocol-layers} dargestellt, in zwei Schichten darstellen.

\begin{table}[htpb]
\caption{TLS-Protokoll Schichten}
\label{tab:tls-protocol-layers}
\resizebox{\textwidth}{!}{%
\begin{tabular}{cccc}
\multicolumn{1}{c|}{TLS Handshake Protocol} & \multicolumn{1}{c|}{TLS Change Cipher Spec. Protocol} & \multicolumn{1}{c|}{TLS Alert Protocol} & TLS Application Data Protocol \\ \hline
\multicolumn{4}{c}{TLS Record Protocol}         
\end{tabular}%
}
\end{table}

\paragraph[TLS-Record Protocol]{\ac{TLS}-Record Protokoll}\label{par:tls_record_protocol}
Das \nameref{par:tls_record_protocol} fragmentiert die Daten in Blöcke, komprimiert sie wenn gewünscht, wendet \ac{MAC} darauf an, verschlüsselt die Daten \ac{E2E} und sie verschickt.\autocite[\vglf][]{Transpor18:online}. Zudem bauen die vier Protokolle 

\begin{itemize}
    \item \nameref{par:tls_handshake_protocol}, 
    \item \ac{TLS}-Change-Cipher-Spec. Protokoll, 
    \item \nameref{par:tls_alert_protocol} und das 
    \item \ac{TLS}-Application-Data Protokoll
\end{itemize}
auf das \nameref{par:tls_record_protocol} auf\autocite[\vglf][]{Transpor18:online}, von denen das \nameref{par:tls_handshake_protocol} und das \nameref{par:tls_alert_protocol} im Folgenden kurz beschrieben werden.
Das \nameref{par:tls_record_protocol} sichert die Schutzziele \gls{vertraulichkeit} und \gls{integritaet}.\autocite[\vglf][]{Transpor18:online}

\paragraph[TLS-Handshake-Protokoll]{\ac{TLS}-Handshake-Protokoll}\label{par:tls_handshake_protocol}
Das \ac{TLS}-Protokoll ist auch in sich noch in einzelne Unterprotokolle eingeteilt, eines davon ist das \ac{TLS}-Handshake-Protokoll, dessen Verlauf in \autoref{fig:ssl-tls-handshake}\autocite[Aus][\pagef 2]{SslTlsFingerprint:2015} dargestellt wird.

\begin{figure}[htpb]
    \centering
    \includegraphics[width=0.75\linewidth]{abbildungen/ssl-tls-handshake.png}
    \caption[Darstellung eines SSL/TLS-Handshakes]{Darstellung eines \ac{SSL}/\ac{TLS}-Handshakes\footnotemark}
    \label{fig:ssl-tls-handshake}
\end{figure}
\footnotetext{\cite[Aus][\pagef 3]{SslTlsFingerprint:2015}}

Mithilfe dieser Handshakes wird ausgehandelt, welche \glsdisp{kryptografie}{Kryptografischen} \glspl{algorithmus} und Schlüssel verwendet werden und die Kommunikationspartner werden identifiziert und \glsdisp{authentifizierung}{authentifiziert}, wobei es üblich ist, dass sich nur der Server bei dem Client \glsdisp{authentifizierung}{authentifiziert}, was als one-way authentication bezeichnet wird\autocite[\vglf][\pagef 191]{morrissey_tls_2010}.

\paragraph[TLS-Alert Protokoll]{\ac{TLS}-Alert Protokoll}\label{par:tls_alert_protocol}

Das \nameref{par:tls_alert_protocol} ist für Alerts während der Übertragung zuständig. Es gibt verschieden Alerts, die in die zwei Stufen \enquote{Closure} und \enquote{Error} unterteilt werden, wobei Error Alerts zu einem sofortigen Abbruch der Verbindung führen.\autocite[\vglf][]{Transpor18:online} Zudem sind sie, wie alle anderen Nachrichten im \ac{TLS}-Protokoll verschluüsselt und komprimiert.\autocite[\vglf][\pagef 85]{RFC8446}

\subsubsection[HTTPS-Protocol]{\ac{HTTPS}-Protokoll}\label{subsubsec:HTTPS-Protocol}

Wie in \autoref{subsubsec:digitale-signaturen-und-zertifikate} bereits dargestellt, sorgt \ac{SSL} dafür, dass eine Anwendung oder ein Nutzer verifizieren kann, dass die angefragten Daten von dem Absender stammen, den man auch angefragt hat. Dies trägt besondere Relevanz bei Webanwendungen, da es sonst möglich ist, unter falschem Namen schädliche Software in ein System einzuspeisen.
Das \ac{HTTP} überträgt Daten über das \ac{TCP}, wohingegen \ac{HTTPS} die Daten verschlüsselt über das \ac{SSL}-Protokoll verschickt \autocites{2674005.2674991:online}{RFC5246T44:online}.

Eine \ac{HTTPS}-Verschlüsselung einer Internetseite sorgt dafür, dass bei der Übertragung Daten, besonders vertrauliche wie z.B. Bankkontoinformationen, nicht von dritten eingesehen werden können\autocite[\vglf][]{CloudfareWarumHTTPS:online}. Zudem sorgt das \ac{SSL}-Zertifikat dafür, dass der Nutzer weiß, der Absender der Daten ist auch das System, das angefragt wurde, wie in \autoref{subsubsec:digitale-signaturen-und-zertifikate} dargestellt. Dadurch wird verhindert, dass ein Angreifer einem Nutzer eine identisch aussehende Internetseite bereitstellt und dadurch die Nutzer glauben lässt, sie seien auf der gewünschten Internetseite\autocite[\vglf][]{CloudfareWarumHTTPS:online}.

\subsection[Passwortsicherheit]{Passwortsicherheit — Key Derivation Function, Salted- \& Peppered-Hashing}\label{subsec:passwortsicherheit}

\subsubsection{Key Derivation Function}\label{subsubsec:key-derivation-function}
Als Key Derivation Function (Schlüsselableitung) wird in der \gls{kryptografie} eine Operation bezeichnet, welche aus einem Schlüssel oder einem Passwort verschiedene andere Schlüsselwerte generiert.\autocite[\vglf][\pagef 3]{NIST:800132} Diese Operation kann in verschiedenen Arten durchgeführt werden, zwei häufig angewandte sind zum einen das Salted Hashing (\autoref{subsubsec:salted-hashing}) und das Peppered Hashing (\autoref{subsubsec:peppered-hashing}), bzw. das kombinierte Anwenden beider dieser Verfahren. Der generierte Schlüssel wird als \ac{MC} bezeichnet.


\subsubsection{Salted Hashing}\label{subsubsec:salted-hashing}
Als Salt wird in der \gls{kryptografie} ein zufälliger String bezeichnet, welcher dem zu verschlüsselnden \gls{klartext} angehangen wird, bevor der Hash-\gls{algorithmus} durchgeführt wird\autocite[\vglf][\pagef 205]{JoyOfCryptography:2021}. Dabei wird am Beispiel von Anmeldedaten einer Internetseite für jeden angelegten Nutzer ein eigener Salt generiert und mit in der Datenbank gespeichert.
Dies verhindert \uamol, dass für zwei Anmeldedaten mit den gleichen Passwörtern der gleiche Hashwert in der Datenbank gespeichert wird.

Durch Salted Hashing das Erstellen einer \gls{Rainbow-Table} überflüssig, beziehungsweise unnötig aufwändig gemacht, da nicht, wie bei einer normalen Hash-Datenbank ein \gls{Rainbow-Table} für die gesamte Datenbank generiert werden muss, sondern für jedes Passwort ein \gls{Rainbow-Table} benötigt wird\autocite[\vglf][\pagef 205]{JoyOfCryptography:2021}.

Der Salt hat, damit er ausreichende Sicherheit bieten kann, zwei Anforderungen. Die eine, Einzigartigkeit, wurde weiter oben bereits aufgeführt. Die zweite Anforderung ist, dass er optimalerweise eine bestimmte Länge haben sollte, allerdings gibt es hier keine genaue Anforderung/ Richtlinie, welche Länge als sicher gilt. Das Patent für Salted Hashing selbst gibt keine vor\autocite[\vglf][\pagef 14]{patent:saltedHashing}, sodass auch innerhalb einer Datenbank verschiedene Längen für Salts verwendet werden können.

Der \ac{NIST}-standard für Schlüsselableitung sieht jedoch vor, dass der \ac{MC}, also die Kombination aus einem Passwort und einem Salt, mindestens eine Länge von 112 bits haben soll.\autocite[\vglf][\pagef 6]{NIST:800132}

\subsubsection{Peppered Hashing}\label{subsubsec:peppered-hashing}

Analog zum Salt und dem Salted Hashing (\autoref{subsubsec:salted-hashing}) gibt es auch die Sicherungsmethode des Pepper, oder des Peppered Hashing.

Bei diesem wird, wie beim Salted Hashing auch, ein zufällig generierter String an den \gls{klartext} angehangen, bevor der Hash-\gls{algorithmus} durchgeführt wird, jedoch ist dieser String aber nicht für jeden Einrag unterschiedlich, sondern wird bei der Einrichtung des Servers festgelegt und geheimgehalten\autocite[\vglf][]{Securing39:online}. Auch dieses Verfahren schützt vor einer möglichen \gls{sqlInject}.
Gleichermaßen gibt es beim Peppered Hashing keine fest vorgelegte Länge, welche der Pepper aufweisen sollte, allerdings empfiehlt es sich auch hier, dass der Pepper möglichst lang gewälht wird.


\subsection[Authentifizierung und Autorisierung]{Authentifizierung und Autorisierung — Token-Verfahren, OAuth}\label{subsec:authenticationAuthorization}
Um Datensicherheit zu gewährleisten, bzw. Datenzugriff zu steuern, werden in Webanwendungen zwei Konzepte Verfolgt: Authentifizierung und Autorisierung. 

Autorisierung befasst sich mit der Zugriffskontrolle über Daten, also welche Geräte oder Nutzer welche Daten lesen und/oder schreiben, Programme ausführen oder Akteure kontrollieren können.\autocite[\vglf][\pagef 28]{Auth:2017} Ebenso bezeichnet Autorisierung das Ablehnen oder Entfernen von Zugriff über Daten, \zbol für \gls{malware}.\autocite[\vglf][\pagef 28]{Auth:2017}

Demgegenüber bezeichnet Authentifizierung den Prozess, einen \gls{client}, Gerät oder Mensch, zu identifizieren und ist eine Grundvoraussetzung für Autorisierungen, da in den meisten Fällen Autorisierung ohne eine zuvorgehende Authentifizierung nicht möglich ist.\autocite[\vglf][\pagef 28]{Auth:2017}
Häufig genutzte Methoden zur Authentifizierung sind die zuvor behandelten digitalen Zertifikate (\autoref{subsubsec:digitale-signaturen-und-zertifikate}), das \nameref{subsubsec:HTTPS-Protocol} (\autoref{subsubsec:HTTPS-Protocol}), sowie Schlüsselableitungen (\autoref{subsec:passwortsicherheit}). Diese werden genutzt, um das Vertrauen zwischen dem \gls{client} und der Anwendung herzustellen.\autocite[\vglf][\pagef 28]{Auth:2017}

\subsubsection[Token-Verfahren]{Access Token}\label{subsubsec:access-token}
Eine häufig genutzte Art, die Autorisierung eines \glspl{client} zu prüfen ist es, einen Access Token zu verschicken.
Diese bestehen üblicherweise aus drei Schlüssellementen, 
\begin{itemize}
    \item dem Header, mit Daten über die Art des Tokens und den \gls{algorithmus}, mit dem dieser generiert wurde,
    \item der Payload, welche die Informationen über den \gls{client} beinhält, darunter auch die Berechtigungen und Ablaufdaten, sowie 
    \item die Signatur, ein Zertifikat (\autoref{subsubsec:digitale-signaturen-und-zertifikate}), das die Echtheit des Tokens garantiert;
\end{itemize}\label{itm:TokenElemente}
zusätzlich können auch weitere Elemente wie z.B. Erweiterungen oder Metadaten angefügt sein, um fallspezifische Anforderungen zu erfüllen.\autocite[\vglf][]{AccessTo39:online}

Eine häufig genutzte Version von Access Token ist der \ac{JWT}. Dieser ist zu großen Teilen bedingt durch seine kompakte Speichergröße.\autocite[\vglf][\pagef 4]{rfc7519} Der \ac{JWT} besteht dabei aus den oben beschriebenen Elementen, die bevor, mit einem '.'  sie zusammengesetzt werden, mit einem \gls{base64}-\gls{algorithmus} verschlüsselt und komprimiert sind.\autocite[\vglf][\pagef 5]{rfc7519}

Ein Minimalcodebeispiel um in der Programmiersprache \ac{JS} einen \ac{JWT} zu generieren, sieht wie folgt aus

\lstinputlisting[language = JavaScript, caption = {Beispielskript zur Generierung eines \ac{JWT}}]{./Quellcode/jwt.js}\label{listing:JWT}

wobei \lstinline!secret! für den \gls{privateKey} des digitalen Zertifikates steht (\autoref{subsubsec:digitale-signaturen-und-zertifikate} steht, \lstinline!base64urlEncoding()! eine Funktion ist, Daten mit einem \gls{base64}-\gls{algorithmus} zu verschlüsseln und \lstinline!HMAC_SHA256()! eine Methode ist, um einen \ac{HMAC} mit dem \gls{SHA256}\nonbreakdash\gls{algorithmus} zu erzeugen.

Dabei wird der Token
\begin{lstlisting}[language = JavaScript]
"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"
\end{lstlisting}
generiert.

\subsubsection[OAuth]{\acf{OAUTH}}\label{subsubsec:oauth}
\ac{OAUTH} bezeichnet ein Framework, welches einem Dateninhaber ermöglicht, Dritten begrenzten Zugriff zu gewähren, \zbol bei \acp{SSO}, oder den gegebenen Zugriff zu beschränken.\autocites[\vglf][\pagef 1]{rfc6749}[\vglf][\pagef  75]{OAuthWebProtocol:2012}

Das OAuth Protokoll verwendet die folgenden 6 Elemente,
\begin{itemize}
    \item einen \gls{client} als den Service, der nach \gls{autorisierung} fragt,
    \item einem Ressourceninhaber als die Entität, die die Information, für die der \gls{client} Zugriff anfragt,
    \item  einen Ressourcen\glsdisp{server}{server} als den Service, der den Zugriff zu den angefragten Informationen vergibt,
    \item einen \glsdisp{autorisierung}{Autorisierungs}\glsdisp{server}{server}, der die Echtheit der Zertifikate des Ressourceninhabers verifiziert und die Überprüfungen für die \gls{autorisierung} durchführt,
    \item einen \nameref{subsubsec:access-token} (\autoref{subsubsec:access-token}), der von dem \glsdisp{autorisierung}{Autorisierungs}\glsdisp{server}{server} generiert wird und dem \gls{client} den Zugriff von dem Ressourcen\glsdisp{server}{server} anfragen lässt und
    \item einen \glsdisp{authentifizierung}{Authentifizierungscode}, den der \glsdisp{autorisierung}{Autorisierungs}\glsdisp{server}{server} während der Anfrage überprüfen kann,
\end{itemize}
um Zugriff anzufragen, beziehungsweise ihn zu überprüfen.\autocite[\vglf][\pagef  75]{OAuthWebProtocol:2012}

\autoref{fig:oauth_protocol_flow}\autocite[\vglf][\pagef 7, Abbildung 1]{rfc6749}  stellt die Kommunikation zwischen dem \gls{client} und der Service\nobreakdash\ac{API} dar. 
\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.7\textwidth]{abbildungen/OAuth_abstract_flow.png}
    \caption[Kommunikationsverlauf im OAuth-Protokoll]{Kommunikationsverlauf im OAuth-Protokoll\footnotemark}
    \label{fig:oauth_protocol_flow}
\end{figure}
\footnotetext{\cite[\vglf][\pagef 7, Abbildung 1]{rfc6749}}
Zunächst stellt der \gls{client} oder eine Applikation eine Anfrage an den Ressourceninhaber  nach einer\gls{autorisierung}. Wenn diese an den \gls{client} bestätigt wird, stellt dieser mit der Bestätigung eine Anfrage nach einem Access Token an den \glsdisp{autorisierung}{Autorisierungs}\glsdisp{server}{server}. Mit dem Access Token stellt der \gls{client} zuletzt noch eine Anfrage an den Ressourcen\glsdisp{server}{server} und erhält von diesem die gewünschten Ressourcen.

OAuth wird primär für \acp{SSO} genutzt, um \zbol einer Anwendung Zugriff auf bestimmte Daten einer anderen Anwendung zu gewähren, ohne die Anmeldedaten direkt zu übergeben, wie etwa Bilder aus einem Cloudservice an einen Druckservice zu übergeben.\autocite[\vglf][\pagef 74]{OAuthWebProtocol:2012}

\subsubsection[2-Factor Authentifizierung]{\acf{2FA}}\label{subsubsec:2fa}
Wie \autoref{tab:statistik_passwort}\autocite{statista_authentifizierung} zeigt, sind Passwörter heutzutage mit Abstand die am weitesten verbreitete Methode, sich bei einem Service zu \glsdisp{authentifizierung}{authentifizieren}.

\begin{table}[htpb]
\caption[Statistik zu Authentifizierungsverfahren zum Schutz von Daten und Geräte]{Statistik zu Authentifizierungsverfahren zum Schutz von Daten und Geräte\footnotemark\newline
\small{Details: Deutschland; 08. bis 14.08.2018; 1.025 Befragte; ab 18 Jahre}}
\label{tab:statistik_passwort}
\resizebox{\textwidth}{!}{%
\begin{tabular}{lr}
\textbf{Merkmal}                                              & \multicolumn{1}{l}{\textbf{Anteil der Befragten}} \\ \hline
Ich nutze ein Passwort                                        & 63                                               \\
Ich nutze einen Fingerabdruckssensor                          & 26                                               \\
Ich nutze eine Zahlenkombination                              & 22                                               \\
Ich nutze ein Muster                                          & 12                                               \\
Ich nutze eine Gesichtserkennung                              & 9                                                \\
Ich nutze eine Spracherkennung                                & 8                                                \\
ich nutze die Online-Ausweisfunktion meines Personalausweises & 7                                                \\
Ich nutze einen Iris-Scanner                                  & 7                                                \\
Ich nutze einen Venen-Scanner                                 & 5                                                \\
Sonstiges                                                     & 0                                                \\
Ich nutze keine Authentifizierungsverfahren                   & 12                                              
\end{tabular}%
}
\end{table}
\footnotetext{\cite{statista_authentifizierung}}
Jedoch bietet ein einzelnes Passwort als \glsdisp{authentifizierung}{Authentifizierungsverfahren} keinen vollständigen Schutz\autocite[\vglf][\pagef 2]{10.1145/3440712},  da Angreifer \zbol durch andere unsichere Software auf dem System einfach an die Nutzerdaten gelangen können. Besonder, wenn man für mehrere verschiedene Systeme das gleiche Passwort nutzt oder einen \ac{SSO}-Service für mehrere Dienste nutzt, sind diese Angriffen deutlich leichter ausgesetzt als wenn für jeden Dienst ein anderes, sicheres, Passwort genutzt wird.

\ac{2FA}-Dienste tragen dazu bei, dass diese Unsicherheiten abgeschafft werden, in dem \zbol ein zusätzliches, verknüpftes Gerät eine Benachrichtigung bekommt, in der man den \glsdisp{authentifizierung}{Authentifizierungsvorgang} bestätigen muss, wie es unter anderem verschiedene Banksysteme mit online banking und einem TAN-Mechanismus machen, oder ein externer Dienst für \ac{2FA}-\acp{OTP} genutzt wird, die in bestimmten Zeitintervallen neue Codes generieren, der zusätzlich zu der primären \glsdisp{authentifizierung}{Authentifizierungsmethode} eingegeben werden müssen.